using Microsoft.ApplicationInsights.Channel;
using Microsoft.ApplicationInsights.DataContracts;
using Serilog.Events;
using Serilog.Sinks.ApplicationInsights.TelemetryConverters;

namespace CheckMade.Chat.Telegram.Startup;

internal class CustomTelemetryConverter : TraceTelemetryConverter
{
    public override IEnumerable<ITelemetry> Convert(LogEvent logEvent, IFormatProvider formatProvider)
    {
        foreach (var telemetry in base.Convert(logEvent, formatProvider))
        {
            var propTelemetry = (ISupportProperties)telemetry; 
            
            if (logEvent.Properties.TryGetValue("SourceContext", out var sourceContext))
            {
                // This tests whether SourceContext is found and this block entered. It is when I tested it first!
                // Console.WriteLine("Entered SourceContext block.");
                
                // This unfortunately doesn't add 'SourceContext' as a field anywhere, neither in 
                // customDimensions nor anywhere else, in the ApplicationInsights log entries! 
                propTelemetry.Properties["SourceContext"] = sourceContext.ToString();
            }

            propTelemetry.Properties["LogLevel"] = logEvent.Level.ToString();

            /* Idea: use this to record the Telegram User Id with logs from my code in a structured way
             
             To make this work, according to GPT, I'll have to use code like this in whichever module does the logging:
             
             telegramUuserId = [extract ID from telegram object]
             var telemetry = new TelemetryClient();
               telemetry.Context.User.Id = telegramUuserId;
               telemetry.TrackEvent("TelegramMessageReceived", new Dictionary<string, string> {
                   { "UserId", telegramUuserId }
               });
             
             */
            if (logEvent.Properties.TryGetValue("UserId", out var userId))
            {
                telemetry.Context.User.Id = userId.ToString();
            }
            
            // Idea: every function invocation has its own operation_Id. I can use this to add an operation_Id
            // to the logs generated by my code, so that it's easy to e.g. filter out all logs that belong to an op.
            if (logEvent.Properties.TryGetValue("operation_Id", out var opId))
            {
                telemetry.Context.User.Id = opId.ToString();
            }

            if (logEvent.Properties.TryGetValue("operation_ParentId", out var opParentId))
            {
                telemetry.Context.User.Id = opParentId.ToString();
            }

            // The below code comes from the Serilog docs and seems sensible to keep in place:
            // https://github.com/serilog-contrib/serilog-sinks-applicationinsights?search=1#customizing
            var redundantProps = new[] { "UserId", "operation_ParentId", "operation_Id" };
            redundantProps = redundantProps.Where(prop => propTelemetry.Properties.ContainsKey(prop)).ToArray();
            
            foreach (var prop in redundantProps)
            {
                propTelemetry.Properties.Remove(prop);
            }
            
            yield return telemetry;
        }
    }
}
