name: .NET .Core Main Branch Workflow

on:
  workflow_dispatch:
  push:
    branches:
      - main

jobs:  
  tag_version:
    runs-on: ubuntu-latest

    steps:
      # By default, fetch-depth=1, which is what's needed for tagging
      - uses: actions/checkout@v4

      - name: Read Version from version.txt
        id: read-version
        run: echo "VERSION=$(cat version.txt)" >> $GITHUB_ENV

      - name: Tag the new version
        run: git tag ${{ env.VERSION }}

      - name: Configure Git
        run: |
          git config user.email "our-github-action-bot@users.noreply.github.com"
          git config user.name "GitHub Actions Bot"
          
      # Uses '--force' to overwrite existing tag in case of repeated push of the same tag e.g. after a quick fix
      - name: Push changes
        run: |
          git push --force origin ${{ env.VERSION }}
  
  build_test_and_deploy:
    needs: tag_version
    runs-on: ubuntu-latest

    services: 
      postgres:
        image: postgres
        env:
          POSTGRES_PASSWORD: my_ci_db_psw
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
    
    strategy:
      matrix:
        toplevel_project: [ "${{ vars.TELEGRAM_TOPLEVEL_PROJECT }}" ]
#                           "${{ vars.DESKTOP_TOPLEVEL_PROJECT }}", 
#                           "${{ vars.ANDROID_TOPLEVEL_PROJECT }}"]

    env:
      # Reducing caching size: Some action runners already have huge libraries. This replaces OS-default of '~/.nuget/packages'
      NUGET_PACKAGES: ${{ github.workspace }}/.nuget/packages

    steps:
      - uses: actions/checkout@v4
      
# Setting up Caches ----------------------------

      # dotnet SDK & Workloads --------------
      
      - name: Cache dotnet SDK and Workloads
        id: cache-dotnet
        uses: actions/cache@v4
        env:
          # Using the solution_config as part of the cache-name to avoid multiple matrix jobs running in parallel 
          # clashing while attempting to form the same cache. See: https://chat.openai.com/share/a7768546-58f8-4f4f-9de5-07a6153495c4
          cache-name: cache-dotnet-${{ matrix.toplevel_project }}
        with:
          path: /usr/share/dotnet
          key: ${{ runner.os }}-build-${{ env.cache-name }}-${{ hashFiles('global.json') }}
        
      - name: Check cache-dotnet hit
        if: steps.cache-dotnet.outputs.cache-hit == 'true'
        run: echo "There was a cache-hit for restoring dotnet SDK & Workload dependencies."

      # dotnet Nuget (solution_config specific) --------------
      
      - name: Generate hash for Nuget Cache (excluding irrelevant .csproj files)
        run: |
          if [[ "${{ matrix.toplevel_project }}" == "${{ vars.DESKTOP_TOPLEVEL_PROJECT }}" ]]; then
            HASH=$(find . -iname '*.csproj' ! -iname '*mobile*' ! -iname '*chat*' -exec cat {} + | shasum -a 256 | awk '{print $1}')
          elif [[ "${{ matrix.toplevel_project }}" == "${{ vars.ANDROID_TOPLEVEL_PROJECT }}" ]]; then
            HASH=$(find . -iname '*.csproj' ! -iname '*ios*' ! -iname '*desktop*' ! -iname '*chat*' -exec cat {} + | shasum -a 256 | awk '{print $1}')
          elif [[ "${{ matrix.toplevel_project }}" == "${{ vars.TELEGRAM_TOPLEVEL_PROJECT }}" ]]; then
            HASH=$(find . -iname '*.csproj' ! -iname '*mobile*' ! -iname '*desktop*' -exec cat {} + | shasum -a 256 | awk '{print $1}')
          else
            echo "Error: The current toplevel_project is not handled for hash generation."
            echo "CS_PROJ_HASH=error" >> $GITHUB_ENV
            exit 1
          fi
          echo "CS_PROJ_HASH=$HASH" >> $GITHUB_ENV
        shell: bash
      
      - name: Cache nuget dependencies
        id: cache-nuget
        uses: actions/cache@v4
        env:
          cache-name: cache-nuget-${{ matrix.toplevel_project }}
        with:
          path: ${{ github.workspace }}/.nuget
          key: ${{ runner.os }}-build-${{ env.cache-name }}-${{ env.CS_PROJ_HASH }}

      - name: Check cache-nuget hit
        if: steps.cache-nuget.outputs.cache-hit == 'true'
        run: echo "There was a cache-hit for restoring nuget dependencies for ${{ matrix.toplevel_project }}."
        
      # NOT Caching Android SDK at this point, see notes in 'parked_workflows.txt'

# Installing SDKs and Frameworks ----------------------------

#      - name: Setup .NET Environment
#        id: setup-dotnet
#        uses: actions/setup-dotnet@v4
#        with:
#          global-json-file: global.json

      - name: Set up JDK 17
        if: matrix.toplevel_project == vars.ANDROID_TOPLEVEL_PROJECT
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'

      - name: Setup Android SDK
        if: matrix.toplevel_project == vars.ANDROID_TOPLEVEL_PROJECT
        uses: android-actions/setup-android@v3
      
      # Installing all needed workloads irrespective of ANDROID vs. DESKTOP distinction:
      # A single cache is used for 'dotnet' b/c it's too hard to specify workload-specific sub-paths for caching
      - name: Install Workloads
        if: ${{ matrix.toplevel_project == vars.ANDROID_TOPLEVEL_PROJECT || 
          matrix.toplevel_project == vars.DESKTOP_TOPLEVEL_PROJECT }}
        run: dotnet workload install wasm-tools android
        
# Build & Test ----------------------------

      # Based on the TOPLEVEL_PROJECT (see matrix strategy) currently processed here, these scripts determine
      # the paths for build output, project dir, project file, test project file etc. by extracting them from .sln file
      # This allows us to keep the build/test commands below generic and use explicit build-output dirs for deployment. 
      # All of this relies on implicit project naming conventions in the CheckMade solution:
      # E.g. if toplevel project is CheckMade.Chat.Telegram then test project is assumed to start with CheckMade.Chat
      # and to end with Test (with other possible parts in the middle).
      
      - name: Set Build & Test Project Parameters
        run: |
          SLN_FILE=$(find . -name '*.sln')
          echo "SLN_FILE: $SLN_FILE"
          
          TOPLEVEL_PROJECT_DEFINITION_LINE=$(grep "Project(\"" $SLN_FILE | grep "${{ matrix.toplevel_project }}" | grep ".csproj")
          echo "TOPLEVEL_PROJECT_DEFINITION_LINE: $TOPLEVEL_PROJECT_DEFINITION_LINE"
          
          TOPLEVEL_PROJECT_DIR=$(echo "$TOPLEVEL_PROJECT_DEFINITION_LINE" | awk -F', ' '{print $2}' | tr -d '"' | sed 's/\\/\//g' | sed 's/\/[^/]*$//')
          echo "TOPLEVEL_PROJECT_DIR: $TOPLEVEL_PROJECT_DIR"
          echo "TOPLEVEL_PROJECT_DIR=$TOPLEVEL_PROJECT_DIR" >> $GITHUB_ENV
          
          TOPLEVEL_PROJECT_FILE=$(echo "$TOPLEVEL_PROJECT_DEFINITION_LINE" | awk -F', ' '{print $2}' | tr -d '"' | sed 's/\\/\//g')
          echo "TOPLEVEL_PROJECT_FILE: $TOPLEVEL_PROJECT_FILE"
          echo "TOPLEVEL_PROJECT_FILE=$TOPLEVEL_PROJECT_FILE" >> $GITHUB_ENV
          
          TEST_PROJECT_NAME_PART=$(echo "${{ matrix.toplevel_project }}" | cut -d'.' -f2)
          echo "TEST_PROJECT_NAME_PART: $TEST_PROJECT_NAME_PART"
          TOPLEVEL_TEST_PROJECT_LINE=$(grep "Project(\"" $SLN_FILE | grep "$TEST_PROJECT_NAME_PART" | grep "Tests.csproj")
          echo "TOPLEVEL_TEST_PROJECT_LINE: $TOPLEVEL_TEST_PROJECT_LINE"
          
          TOPLEVEL_TEST_PROJECT_FILE=$(echo "$TOPLEVEL_TEST_PROJECT_LINE" | awk -F', ' '{print $2}' | tr -d '"' | sed 's/\\/\//g')
          echo "TOPLEVEL_TEST_PROJECT_FILE: $TOPLEVEL_TEST_PROJECT_FILE"
          echo "TOPLEVEL_TEST_PROJECT_FILE=$TOPLEVEL_TEST_PROJECT_FILE" >> $GITHUB_ENV
          
          TARGET_FRAMEWORK=$(cat Directory.Build.props | grep '<TargetFramework>' | \
          sed -n 's/.*<TargetFramework>\(.*\)<\/TargetFramework>.*/\1/p')
          echo "TARGET_FRAMEWORK: $TARGET_FRAMEWORK"
          
          BUILD_OUTPUT_PATH="$TOPLEVEL_PROJECT_DIR/bin/Release/$TARGET_FRAMEWORK/"
          echo "BUILD_OUTPUT_PATH: $BUILD_OUTPUT_PATH"
          echo "BUILD_OUTPUT_PATH=$BUILD_OUTPUT_PATH" >> $GITHUB_ENV
      
      # Re OUTPUT path: even if it's the default output path, need it explicit for deployment step further down!
#      - name: Build
#        run: |
#          dotnet build ${{ env.TOPLEVEL_PROJECT_FILE }} --configuration Release --output ${{ env.BUILD_OUTPUT_PATH }}
      
      - name: Set up PostgreSQL Db Cluster
        run: |
          DB_CLUSTER_PATH="$HOME/MyPostgresDBs/CheckMade"
          DB_SUPERUSER=$(whoami)
          initdb --pgdata=$DB_CLUSTER_PATH --auth-host=md5 --username=$DB_SUPERUSER
          pg_ctl -D $DB_CLUSTER_PATH start
          psql -l
      
#      - name: Test
#        run: |
#          dotnet test ${{ env.TOPLEVEL_TEST_PROJECT_FILE }} --configuration Release --verbosity minimal
#        env:
#          HOSTING_ENVIRONMENT: "CI"
#          CI_DB_CONNSTRING: ${{ secrets.CI_DB_CONNSTRING }}
            
      #  Deploy ---------------------------------

#      - name: Deploy Telegram Function to Azure
#        if: ${{ matrix.toplevel_project == vars.TELEGRAM_TOPLEVEL_PROJECT }}
#        uses: Azure/functions-action@v1
#        with:
#          app-name: 'telegram-app-d4e8'
#          slot-name: 'production'
#          package: ${{ env.BUILD_OUTPUT_PATH }}
#          publish-profile: ${{ secrets.AZUREAPPSERVICE_PUBLISHPROFILE_TELEGRAM_APP_D4E8 }}
          